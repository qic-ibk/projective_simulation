# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/lib_nbs/03_agents.ipynb.

# %% auto 0
__all__ = ['Abstract_Agent', 'Basic_PSAgent', 'Situated_Agent']

# %% ../nbs/lib_nbs/03_agents.ipynb 2
# From lib
import projective_simulation.methods.preprocessors as preprocessors
import projective_simulation.ECMs as ECMs

# From others
from abc import ABC, abstractmethod

# %% ../nbs/lib_nbs/03_agents.ipynb 4
class Abstract_Agent(ABC):
    """
    A minimal class every agent should fullfill, every agent should be Derived from this class
    """

    def __init__(self, 
                 ECM = None, #The ECM Object to use
                 percept_processor = None, #An optional object for transforming observations prior to passing to ECM as a percept. Must have method "preprocess" 
                 action_processor = None #An optional object for transforming actions prior to passing to Environment as an actuator state. Must have method "postprocess" 
                ):
        self.ECM = ECM
        assert ECM is not None

        self.percept_processor = percept_processor
        if percept_processor is not None:
            assert hasattr(percept_processor, "get_percept")

        self.action_processor = action_processor
        if action_processor is not None:
            assert hassattr(action_processor, "postprocess")

    @abstractmethod
    def update(self, 
               reward, #used to reinforce agent parameters based on desirable or aversive states
               observation #data object passed from the environment/sensors
              ):

        raise NotImplementedError
    
    @abstractmethod
    def get_action(self, 
                   percept #Data object to be processed by ECM. Likely a list np.array
                  ):

        raise NotImplementedError

# %% ../nbs/lib_nbs/03_agents.ipynb 6
class Basic_PSAgent(Abstract_Agent):
    def __init__(self, 
                 ECM = None, #if an ECM object is not given, a number of actions must be given with whi
                 num_actions = None, # The number of available actions. If an ECM is not given, should be int
                 glow: float = 0.1, # The glow (or eta) parameter. Won't be used if ECM is given
                 damp: float = 0., # The damping (or gamma) parameter. Won't be used if ECM is given
                 softmax: float = 0.1, # The softmax (or beta) parameter. Won't be used if ECM is given
                 percept_processor = preprocessors.get_percept, 
                 action_processor = None
                ):
        """
        Simple, projective simulation (PS) agent that uses a two-layer ECM. Percepts are added to the ECM as new obsevations are encountered
                      
        NOTE: This simple version misses some features such as clip deletion, emotion tags or generalization mechanisms.
        
        """
        assert isinstance(ECM, ECMs.Two_Layer) or isinstance(num_actions, int)
        
        if ECM is None:
            self.ECM = ECMs.Two_Layer(num_actions, glow, damp, softmax)
        else:
            self.ECM = ECM

        self.percept_processor = percept_processor        
        
        
    def get_action(self, 
                observation: object # data object passed from the environment/sensors
               )-> int : # The action to be performed.
        """
        Given a percept, returns an action. For basic PS, these processess are mainly executed by the ECM's deliberate function
        """
        percept = self.percept_processor(observation)
        action = self.ECM.deliberate(percept)
        return action

    def update(self, 
               reward #Value used for reinforcement. Likely a float
              ):
        """
        Given a reward, updates h-matrix. Updates g-matrix with glow.
        """
        self.ECM.learn(reward)

# %% ../nbs/lib_nbs/03_agents.ipynb 8
class Situated_Agent(Abstract_Agent):
    def __init__(self, 
                 reflexes = None, #if an ECM object is not given, a number of actions must be given with which to create one
                 ECM = None, #if an ECM object is not given, a memory capacity must be given. This will be used to creat a new ECM
                 num_actions = None, # The number of available actions. If an ECM is not given, should be int
                 N_traces:int = None,
                 glow: float = 0.1, # The glow (or eta) parameter. Won't be used if reflexes is given
                 damp: float = 0., # The damping (or gamma) parameter. Won't be used if reflexes is given
                 reflex_softmax: float = 1., # The softmax (or beta) parameter. Won't be used if reflexes is given
                 t = 0,
                 percept_processor = None, 
                 action_processor = None
                ):
        assert isinstance(reflexes, ECMs.Priming_ECM) or isinstance(num_actions, int)
        if reflexes is None:
            self.reflexes = ECMs.Priming_ECM(num_actions, glow, damp, reflex_softmax)
        else:
            self.reflexes= reflexes

        if ECM is None:
            self.ECM = ECMs.Active_Inference_Memory_Network(num_actions = 2)
        else:
            self.ECM = ECM
        assert self.reflexes.num_actions == self.ECM.num_actions
        self.num_actions = self.reflexes.num_actions

        super().__init__(ECM = self.ECM, percept_processor = percept_processor)

        if self.percept_processor is None:
            self.percept_processor = preprocessors.action_factorizor(num_actions = self.num_actions)

        self.surprise = None

    def get_action(self, sensory_state):
        '''
        runs the SiPS agent preprocessor and deliberation. Observation should be a list or int.
        '''
        action = self.reflexes.deliberate(str(sensory_state))
        percept = self.percept_processor.get_percept(sensory_state, action)
        self.reflexes.action_primes = self.ECM.deliberate(percept) #runs predictions, priming actions for next step.
        return(action)

    def update(self):
        reward = np.nanmean(self.ECM.valences) - self.surprise
        self.reflexes.learn(reward)
