"""This notebook gathers the most basic implementation of PS"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/lib_nbs/agents/01_basic_PS.ipynb.

# %% auto 0
__all__ = ['Basic_PSAgent']

# %% ../../nbs/lib_nbs/agents/01_basic_PS.ipynb 2
import numpy as np
from .abstract_agent import PS_Agent
from ..ECMs.two_layer import Two_Layer
from ..methods.preprocessors import get_percept
from ..utils import _softmax


class Basic_PSAgent(PS_Agent):
    def __init__(self, 
                 ECM = None, #an ECM object is not given, a number of actions must be given with whi
                 num_actions = None, # The number of available actions. If an ECM is not given, should be int
                 glow: float = 0.1, # The glow (or eta) parameter. Won't be used if ECM is given
                 damp: float = 0., # The damping (or gamma) parameter. Won't be used if ECM is given
                 softmax: float = 0.1, # The softmax (or beta) parameter. Won't be used if ECM is given
                 percept_processor = get_percept, 
                 action_processor = None
                ):
        """
        Simple, projective simulation (PS) agent that uses a two-layer ECM. Percepts are added to the ECM as new obsevations are encountered
                      
        NOTE: This simple version misses some features such as clip deletion, emotion tags or generalization mechanisms.
        
        """
        assert isinstance(ECM, Two_Layer) or isinstance(num_actions, int)
        if ECM is None:
            self.ECM = Two_Layer(num_actions, glow, damp, softmax)
        else:
            self.ECM = ECM

        self.percept_processor = percept_processor        
        
        
    def deliberate(self, 
                percept: str # .
               )-> int : # The action to be performed.
        """
        Given a percept, returns an action.
        (1) If percept is new, add to ECM
        (2) Get action from percept and h-values.
        (3) Update g-matrix.
        """
        #(1) add new percept
        if percept not in self.ECM.percepts.keys(): 
            self.ECM.percepts[percept] = self.ECM.num_percepts
            # increment number of percepts
            self.ECM.num_percepts += 1
            # add column to h-matrix
            self.ECM.hmatrix = np.append(self.ECM.hmatrix, 
                                     np.ones([1,self.ECM.num_actions]),
                                     axis=0)
            # add column to g-matrix
            self.ECM.gmatrix = np.append(self.ECM.gmatrix, 
                                    np.zeros([1,self.ECM.num_actions]),
                                    axis=0)
        #(2) get action
        # get index from dictionary entry
        percept_index = self.ECM.percepts[percept]
        # get h-values
        h_values = self.ECM.hmatrix[percept_index]
        # get probabilities from h-values through a softmax function
        prob = _softmax(self.ECM.softmax, h_values)
        # get action
        action = np.random.choice(range(self.ECM.num_actions), p=prob)        
        #(3) update g-matrix
        self.ECM.gmatrix[int(percept_index),int(action)] = 1.

        return action

    def update(self, reward):
        """
        Given a reward, updates h-matrix. Updates g-matrix with glow.
        """
        # damping h-matrix
        self.ECM.hmatrix = self.ECM.hmatrix - self.ECM.damp*(self.ECM.hmatrix-1.)
        # update h-matrix
        self.ECM.hmatrix += reward*self.ECM.gmatrix
        # update g-matrix
        self.ECM.gmatrix = (1-self.ECM.glow)*self.ECM.gmatrix

    

